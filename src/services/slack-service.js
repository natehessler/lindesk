import fetch from 'node-fetch';
import { getConfig } from '../config.js';

/**
 * Posts a help request to Slack with a summary and next steps
 * @param {Object} analysis - The AI-generated analysis of the thread
 * @param {string} threadId - The Plain thread ID
 * @param {string} teamChannel - The Slack channel ID to post to
 * @param {string} organizationName - The organization name
 * @returns {Promise<Object>} - The Slack message response
 */
export async function postToSlack(analysis, threadId, teamChannel, organizationName) {
  const { slackToken } = getConfig();
  
  if (!slackToken) {
    throw new Error('Slack token not configured. Run "lindesk setup" first.');
  }

  if (!teamChannel) {
    throw new Error('Slack channel not specified. Use --channel option.');
  }

  const ticket = analysis.ticket || {};
  const customerName = organizationName || ticket.organization || 'Customer';
  
  // Create a focused help request, not just a dump of the analysis
  const slackBlocks = buildSlackBlocks(analysis, threadId, customerName);
  
  console.log('Posting help request to Slack channel...');
  const response = await fetch('https://slack.com/api/chat.postMessage', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${slackToken}`
    },
    body: JSON.stringify({
      channel: teamChannel,
      blocks: slackBlocks,
      text: `Help needed: ${analysis.title || analysis.originalSubject}` // Fallback text
    })
  });

  const data = await response.json();

  if (!data.ok) {
    throw new Error(`Slack API error: ${data.error || JSON.stringify(data)}`);
  }
  
  return data;
}

function buildSlackBlocks(analysis, threadId, customerName) {
  const blocks = [];
  
  // Header - make it clear this is a help request
  blocks.push({
    type: "header",
    text: {
      type: "plain_text",
      text: `ðŸ†˜ Help Needed: ${truncate(analysis.title || analysis.originalSubject, 100)}`,
      emoji: true
    }
  });
  
  // Context about the customer and thread
  blocks.push({
    type: "context",
    elements: [
      {
        type: "mrkdwn",
        text: `*Customer:* ${customerName} | *Thread:* #${threadId}`
      }
    ]
  });
  
  blocks.push({ type: "divider" });
  
  // Issue Summary section
  const summary = extractIssueSummary(analysis);
  blocks.push({
    type: "section",
    text: {
      type: "mrkdwn",
      text: `*ðŸ“‹ Issue Summary*\n${summary}`
    }
  });
  
  // What we've found from Deep Search
  const findings = extractKeyFindings(analysis);
  if (findings) {
    blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*ðŸ” What Deep Search Found*\n${findings}`
      }
    });
  }
  
  // What help is needed
  blocks.push({
    type: "section",
    text: {
      type: "mrkdwn",
      text: `*â“ Help Needed With*\n${extractHelpNeeded(analysis)}`
    }
  });
  
  // Suggested next steps
  const nextSteps = extractNextSteps(analysis);
  blocks.push({
    type: "section",
    text: {
      type: "mrkdwn",
      text: `*ðŸ“ Suggested Next Steps*\n${nextSteps}`
    }
  });
  
  blocks.push({ type: "divider" });
  
  // Action buttons
  blocks.push({
    type: "actions",
    elements: [
      {
        type: "button",
        text: {
          type: "plain_text",
          text: "View in Plain",
          emoji: true
        },
        url: `https://app.plain.com/thread/${threadId}`,
        style: "primary"
      }
    ]
  });
  
  // Footer context
  blocks.push({
    type: "context",
    elements: [
      {
        type: "mrkdwn",
        text: "_This request was generated by Lindesk AI analysis. Full analysis available in the thread._"
      }
    ]
  });
  
  return blocks;
}

function extractIssueSummary(analysis) {
  const description = analysis.description || '';
  
  // Try to get the first paragraph that describes the issue
  const lines = description.split('\n').filter(l => l.trim());
  
  for (const line of lines) {
    // Skip headers
    if (line.startsWith('#')) continue;
    // Skip very short lines
    if (line.length < 30) continue;
    
    // Clean up the line
    let summary = line
      .replace(/^\*\*[^*]+\*\*\s*/, '') // Remove bold prefixes
      .replace(/^[-â€¢]\s*/, '') // Remove bullet points
      .trim();
    
    if (summary.length > 30) {
      return truncate(summary, 500);
    }
  }
  
  // Fallback to original subject
  return analysis.originalSubject || 'Customer reported an issue that needs investigation.';
}

function extractKeyFindings(analysis) {
  const description = analysis.description || '';
  
  // Look for root cause or key findings sections
  const patterns = [
    /(?:root cause|the (?:main )?(?:issue|problem) is|key finding)[:\s]*([^\n]+(?:\n[-â€¢][^\n]+)*)/i,
    /(?:identified|found|discovered)[:\s]*([^\n]+)/i,
  ];
  
  for (const pattern of patterns) {
    const match = description.match(pattern);
    if (match && match[1]) {
      return truncate(match[1].trim(), 400);
    }
  }
  
  // Look for any bullet points near the start
  const bullets = description.match(/^[-â€¢]\s*.+$/gm);
  if (bullets && bullets.length > 0) {
    return bullets.slice(0, 3).map(b => b.trim()).join('\n');
  }
  
  return null;
}

function extractHelpNeeded(analysis) {
  // Based on the analysis, determine what help is needed
  const description = analysis.description || '';
  
  // Check for explicit help needed sections
  const helpMatch = description.match(/(?:help needed|need help|require assistance)[:\s]*([^\n]+)/i);
  if (helpMatch) {
    return truncate(helpMatch[1].trim(), 300);
  }
  
  // Generate based on content
  const helpItems = [];
  
  if (description.toLowerCase().includes('bug') || description.toLowerCase().includes('error')) {
    helpItems.push('â€¢ Confirm if this is a known issue or new bug');
  }
  if (description.toLowerCase().includes('config') || description.toLowerCase().includes('setting')) {
    helpItems.push('â€¢ Verify correct configuration approach');
  }
  if (description.toLowerCase().includes('performance') || description.toLowerCase().includes('slow')) {
    helpItems.push('â€¢ Review performance implications');
  }
  
  if (helpItems.length === 0) {
    helpItems.push('â€¢ Review the analysis and provide guidance');
    helpItems.push('â€¢ Suggest best approach for customer response');
  }
  
  return helpItems.join('\n');
}

function extractNextSteps(analysis) {
  const description = analysis.description || '';
  
  // Look for next steps or recommendations
  const patterns = [
    /(?:next steps|recommendations|to resolve)[:\s]*\n((?:[-â€¢\d].*\n?)+)/i,
    /(?:suggest|recommend)[:\s]*\n((?:[-â€¢\d].*\n?)+)/i,
  ];
  
  for (const pattern of patterns) {
    const match = description.match(pattern);
    if (match && match[1]) {
      const steps = match[1].trim().split('\n').slice(0, 4);
      return steps.map(s => s.trim()).join('\n');
    }
  }
  
  // Default next steps
  return `â€¢ Review analysis findings
â€¢ Investigate identified code areas
â€¢ Draft customer response
â€¢ Escalate if needed`;
}

function truncate(str, maxLength) {
  if (!str) return '';
  if (str.length <= maxLength) return str;
  return str.substring(0, maxLength - 3) + '...';
}
