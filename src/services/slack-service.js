import fetch from 'node-fetch';
import { getConfig } from '../config.js';

export async function postToSlack(analysis, threadId, channelId, thread) {
  const { slackToken, plainWorkspaceId } = getConfig();
  
  if (!slackToken) {
    throw new Error('Slack token not configured. Set SLACK_TOKEN environment variable.');
  }
  
  if (!plainWorkspaceId) {
    throw new Error('Plain workspace ID not configured. Set PLAIN_WORKSPACE_ID environment variable.');
  }

  const customerName = thread.organization || thread.customer?.name || 'Unknown';
  const blocks = buildSlackBlocks(analysis, threadId, customerName, thread, plainWorkspaceId);
  
  const response = await fetch('https://slack.com/api/chat.postMessage', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${slackToken}`
    },
    body: JSON.stringify({
      channel: channelId,
      blocks: blocks,
      text: `Deep Search Analysis: ${analysis.originalSubject || thread.subject}`
    })
  });

  const data = await response.json();

  if (!data.ok) {
    throw new Error(`Slack API error: ${data.error || JSON.stringify(data)}`);
  }
  
  return data;
}

function buildSlackBlocks(analysis, threadId, customerName, thread, workspaceId) {
  const blocks = [];
  const threadUrl = `https://app.plain.com/workspace/${workspaceId}/thread/${threadId}/`;
  
  // Header
  blocks.push({
    type: "header",
    text: {
      type: "plain_text",
      text: `üîç Deep Search Analysis`,
      emoji: true
    }
  });
  
  // Thread info
  blocks.push({
    type: "section",
    fields: [
      {
        type: "mrkdwn",
        text: `*Customer:*\n${customerName}`
      },
      {
        type: "mrkdwn",
        text: `*Thread:*\n<${threadUrl}|View in Plain>`
      }
    ]
  });
  
  blocks.push({
    type: "section",
    text: {
      type: "mrkdwn",
      text: `*Subject:* ${analysis.originalSubject || thread.subject || 'N/A'}`
    }
  });
  
  blocks.push({ type: "divider" });
  
  // Deep Search Analysis - split into chunks if needed (Slack has 3000 char limit per block)
  const analysisText = analysis.description || 'No analysis available.';
  const chunks = splitIntoChunks(analysisText, 2900);
  
  blocks.push({
    type: "section",
    text: {
      type: "mrkdwn",
      text: `*üìã Analysis*`
    }
  });
  
  chunks.forEach(chunk => {
    blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: chunk
      }
    });
  });
  
  // Code references
  if (analysis.sources && analysis.sources.length > 0) {
    blocks.push({ type: "divider" });
    
    let sourcesText = '*üìÅ Relevant Code References*\n';
    const topSources = analysis.sources.slice(0, 5);
    topSources.forEach(source => {
      if (source.url) {
        sourcesText += `‚Ä¢ <${source.url}|${source.title || 'Source'}>\n`;
      }
    });
    
    blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: sourcesText
      }
    });
  }
  
  // Suggested follow-ups
  if (analysis.suggestedFollowups && analysis.suggestedFollowups.length > 0) {
    blocks.push({ type: "divider" });
    
    let followupsText = '*üí° Suggested Follow-up Questions*\n';
    analysis.suggestedFollowups.slice(0, 3).forEach(followup => {
      followupsText += `‚Ä¢ ${followup}\n`;
    });
    
    blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: followupsText
      }
    });
  }
  
  // Footer
  blocks.push({ type: "divider" });
  
  blocks.push({
    type: "context",
    elements: [
      {
        type: "mrkdwn",
        text: `_Generated by Lindesk using Sourcegraph Deep Search_`
      }
    ]
  });
  
  return blocks;
}

function splitIntoChunks(text, maxLength) {
  const chunks = [];
  let remaining = text;
  
  while (remaining.length > 0) {
    if (remaining.length <= maxLength) {
      chunks.push(remaining);
      break;
    }
    
    // Find a good break point (newline or space)
    let breakPoint = remaining.lastIndexOf('\n', maxLength);
    if (breakPoint < maxLength / 2) {
      breakPoint = remaining.lastIndexOf(' ', maxLength);
    }
    if (breakPoint < maxLength / 2) {
      breakPoint = maxLength;
    }
    
    chunks.push(remaining.substring(0, breakPoint));
    remaining = remaining.substring(breakPoint).trim();
  }
  
  return chunks;
}
