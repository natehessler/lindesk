-   Application engineer: Stomzy Mwendwa
-   Customer: Cresta 
-   Date: June 24, 2022
-   Version: ​No info.
-   Deployment: No info
-   External Services: No info
-   Auth Providers: No info
-   Slack Links: https://sourcegraph.slack.com/archives/C03JMN66WMC/p1656113432798989
-   GitHub Issue Link: N/A
-   Doc Update Link: N/A
About how "Go to Definitions" works across the repos. Here is the use case I tested. The latest code in repo R1 imports a symbol S from a dependency package P @ version N which is published by repo R2 at commit R2C1. And later on, repo R2 got one commit R2C10 which modified the symbol definition, and a package P version N+1 is published. But repo R1 hasn't been updated to use version N+1 of P yet. Then later on more commits for other files in repo R2 which advanced it to R2C20. When checking the search result in repo R1, and try to "Go to Definitions" of symbol S. Sourcegraph could list those potential definition repos and locations, e.g. repo R2. (screenshot 1) Then when I click on the definition code snippet line number, Sourcegraph jumps to a search in the repo R2, with the search query looks like: repo:\
Great observation with indexing and code intel on this one. I can help explain this phenomenon. Indexed-search is usually working hard to catch up to commits being pushed to repositories. Say for example, a new commit C21 is pushed to the repository. There will be a period of a couple seconds or minutes depending on the repository until this is indexed and then searched. Knowing that there can be a discrepancy between results, we tend to persist the commit hash along with the search result paths, which is why; Sourcegraph jumps to a search in the repo R2, with the search query looks like:  repo:\
However, we do not take the commit from the search result, we simply take latest commit on HEAD. So there's this discrepancy between commits while zoekt indexes,  the search runs and fetching latest head for a repo returns results for different states.If multiple commits have gone by since an indexing job ran, then the latest is the one we will default to.With regards to precise code intel, repository, commits and path inputs are used to determine which uploads can satisfy a particular search query. If for an example, an precise code intel upload may have been indexed on another commit, the output will be as a result of a git diff between the two commits that adjusts the path and line number. This path will be referenced to query definitions at that position.In the case of search-based code intel, here is the query path for symbols: Symbols service with Rockskip enabled: if Rockskip is enabled, it'll search for symbols stored in Postgres. After initial indexing, queries should be resolved quickly. Symbols service with an index for the commit: if the symbols service has already indexed this commit (i.e. someone has visited the commit before) then the query should be resolved quickly. Indexes are deleted in LRU fashion to remain under the configured maximum disk usage which defaults to 100GB. Symbols service with an index for a different commit: if the symbols service has already indexed a different commit in the same repository, then it will make a copy of the previous index on disk then run ctags on the files that changed between the two commits and update the symbols in the new index. This process takes roughly 20 seconds on a monorepo with 40M LOC and 400K files. Symbols service without any indexes (cold start): if the symbols service has never seen this repository before, then it needs to run ctags on all symbols and construct the index from scratch. This process takes roughly 20 minutes on a monorepo with 40M LOC and 400K files.
Based on your observation, I believe you'd be looking to somehow have Sourcegraph keep old commits for changed lines/dependencies(which I'm not sure if it's currently possible keeping all patch versions alive. And I just realized that for my test above, I only get imprecise search-based code intelligence Go to Definition results, but no precise code intelligence results. Is this a configuration or repo setup issue? Will we be able to fix this?
I think Rockskip can help out with this as well as setting up precise code intel.
